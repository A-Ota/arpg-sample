{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.typed-array.uint8-array.js","webpack:///./src/pixi-tilemap/CanvasTileRenderer.ts","webpack:///./src/pixi-tilemap/Constant.ts","webpack:///./src/pixi-tilemap/RectTileLayer.ts","webpack:///./src/pixi-tilemap/CompositeRectTileLayer.ts","webpack:///./src/pixi-tilemap/GraphicsLayer.ts","webpack:///./src/pixi-tilemap/MultiTextureResource.ts","webpack:///./src/pixi-tilemap/shaderGenerator.ts","webpack:///./src/pixi-tilemap/RectTileShader.ts","webpack:///./src/pixi-tilemap/TileRenderer.ts","webpack:///./src/pixi-tilemap/ZLayer.ts","webpack:///./node_modules/core-js/modules/es.date.now.js","webpack:///./node_modules/core-js/modules/es.array-buffer.constructor.js","webpack:///./node_modules/core-js/modules/es.typed-array.uint32-array.js"],"names":["createTypedArrayConstructor","init","data","byteOffset","length","this","renderer","tileAnim","dontUseTransform","cr","registerPlugin","Constant","maxTextures","bufferSize","boundSize","boundCountPerBuffer","use32bitIndex","SCALE_MODE","LINEAR","DO_CLEAR","POINT_STRUCT_SIZE","zIndex","texture","modificationMarker","_$_localBounds","shadowColor","Float32Array","_globalMat","pointsBuf","hasAnim","offsetX","offsetY","compositeParent","vbId","vb","vbBuffer","vbArray","vbInts","initialize","textures","Array","baseTexture","clear","texture_","x","y","animX","animY","textureIndex","from","found","textureList","i","addRect","frame","orig","width","height","rotate","u","v","tileWidth","tileHeight","animCountX","animCountY","pb","push","addFramePad","offset","count","plugin","plugins","tilemap","wt","worldTransform","context","setTransform","a","b","c","d","tx","resolution","ty","renderCanvasCore","points","fillStyle","n","x1","y1","x2","y2","w","h","drawImage","getDrawableSource","globalAlpha","fillRect","destroy","shader","getShader","batch","setObjectRenderer","uniforms","projTransMatrix","globalUniforms","projectionMatrix","copyTo","append","animationFrame","renderWebGLCore","rectsCount","bindTextures","bind","createVb","id","checkIndexBuffer","vertexBuf","getBuffer","vertices","vertPerQuad","vs","stride","byteLength","bk","ArrayBuffer","Uint32Array","update","arr","sz","textureId","shiftU","shiftV","eps","animWidth","animHeight","animXEncoded","animYEncoded","u0","v0","u1","v1","u2","v2","u3","v3","w2","h2","cX","cY","add","NW","uX","uY","geometry","draw","TRIANGLES","anim","minX","minY","maxX","maxY","_bounds","addFrame","transform","rect","children","getRectangle","call","options","destroyVb","bitmaps","texPerChild","_lastLayer","apply","arguments","z","setBitmaps","Error","len1","len2","Math","ceil","slice","layer","addChild","childIndex","tileRotate","tileAnimX","tileAnimY","ind","child","tex","j","visible","worldAlpha","renderable","layers","isModified","clearModify","_clearBuffer","baseTex","boundSprites","dirties","bounds","spr","position","dirtyId","glTexture","gl","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","undefined","alphaMode","UNPACK","texImage2D","target","format","type","doClear","Uint8Array","res","resource","valid","source","texSubImage2D","Resource","fillSamplers","sampleValues","uSamplers","samplerSize","uSamplerSize","generateFragmentSrc","fragmentSrc","replace","generateSampleSrc","src","rectShaderFrag","rectShaderVert","shaderVert","shaderFrag","vertSize","lastTimeAccess","buf","addAttribute","sn","indexBuffer","ibLen","texLoc","texResources","rectShader","initBounds","scaleMode","wrapMode","CLAMP","len","bindTexturesWithoutRT","multi","setTexture","gltsUsed","geom","addIndex","Date","now","size","totalIndices","createIndicesForQuads","$","stat","getTime","global","arrayBufferModule","setSpecies","ARRAY_BUFFER","NativeArrayBuffer","forced"],"mappings":"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","file":"js/chunk-5a537af1.65262c4b.js","sourcesContent":["var createTypedArrayConstructor = require('../internals/typed-array-constructor');\n\n// `Uint8Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint8', function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","/// <reference path=\"types.d.ts\" />\n\nimport { Renderer } from '@pixi/core';\nimport * as PIXI from \"pixi.js\"\n\nexport class CanvasTileRenderer {\n    renderer: Renderer;\n    tileAnim = [0, 0];\n    dontUseTransform = false;\n\n    constructor(renderer: Renderer) {\n        this.renderer = renderer;\n        this.tileAnim = [0, 0];\n    }\n}\n\nconst cr = (PIXI as any).CanvasRenderer;\n\nif (cr) {\n    cr.registerPlugin('tilemap', CanvasTileRenderer);\n}\n","/// <reference path=\"types.d.ts\" />\n\nimport { SCALE_MODES } from '@pixi/constants';\n\nexport const Constant = {\n    maxTextures: 16,\n    bufferSize: 2048,\n    boundSize: 1024,\n    boundCountPerBuffer: 1,\n    use32bitIndex: false,\n    SCALE_MODE: SCALE_MODES.LINEAR,\n    DO_CLEAR: true\n};","// @ts-nocheck\n/// <reference path=\"types.d.ts\" />\n\nimport { Container, Bounds } from '@pixi/display';\nimport { Constant } from './Constant';\nimport { DRAW_MODES } from '@pixi/constants';\nimport { Texture, Renderer } from '@pixi/core';\nimport { TileRenderer } from './TileRenderer';\nimport { Matrix, Rectangle, groupD8 } from '@pixi/math';\n\nimport type { RectTileGeom } from './RectTileShader';\n\nexport const POINT_STRUCT_SIZE = 12;\n\nexport class RectTileLayer extends Container {\n    constructor(zIndex: number, texture: Texture | Array<Texture>) {\n        super();\n        this.initialize(zIndex, texture);\n    }\n\n    zIndex = 0;\n    modificationMarker = 0;\n    _$_localBounds = new Bounds();\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    _globalMat: Matrix = null;\n\n    pointsBuf: Array<number> = [];\n    hasAnim = false;\n    textures: Array<Texture>;\n\n    offsetX = 0;\n    offsetY = 0;\n    compositeParent = false;\n    tileAnim: Array<number> = null;\n\n    initialize(zIndex: number, textures: Texture | Array<Texture>) {\n        if (!textures) {\n            textures = [];\n        } else if (!(textures instanceof Array) && (textures as Texture).baseTexture) {\n            textures = [textures as Texture];\n        }\n        this.textures = textures as Array<Texture>;\n        this.zIndex = zIndex;\n        // this.visible = false;\n    }\n\n    clear() {\n        this.pointsBuf.length = 0;\n        this.modificationMarker = 0;\n        this._$_localBounds.clear();\n        this.hasAnim = false;\n    }\n\n    addFrame(texture_: Texture | String | number, x: number, y: number, animX: number, animY: number) {\n        let texture: Texture;\n        let textureIndex = 0;\n\n        if (typeof texture_ === \"number\") {\n            textureIndex = texture_;\n            texture = this.textures[textureIndex];\n        } else {\n            if (typeof texture_ === \"string\") {\n                texture = Texture.from(texture_);\n            } else {\n                texture = texture_ as Texture;\n            }\n\n            let found = false;\n            let textureList = this.textures;\n            for (let i = 0; i < textureList.length; i++) {\n                if (textureList[i].baseTexture === texture.baseTexture) {\n                    textureIndex = i;\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                // textureIndex = this.textures.length;\n                // this.textures.push(texture);\n                return false;\n            }\n        }\n\n        this.addRect(textureIndex, texture.frame.x, texture.frame.y, x, y, texture.orig.width, texture.orig.height, animX, animY, texture.rotate);\n        return true;\n    }\n\n    addRect(textureIndex: number, u: number, v: number, x: number, y: number, tileWidth: number, tileHeight: number,\n            animX: number = 0, animY: number = 0, rotate: number = 0, animCountX: number = 1024, animCountY: number = 1024): this {\n        let pb = this.pointsBuf;\n        this.hasAnim = this.hasAnim || animX > 0 || animY > 0;\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(rotate);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureIndex);\n        pb.push(animCountX);\n        pb.push(animCountY);\n\n        this._$_localBounds.addFramePad(x, y, x+tileWidth, y+tileHeight, 0, 0);\n\n        return this;\n    }\n\n    tileRotate(rotate: number) {\n        const pb = this.pointsBuf;\n        pb[pb.length - 3] = rotate;\n    }\n\n    tileAnimX(offset: number, count: number) {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - 5] = offset;\n        pb[pb.length - 2] = count;\n    }\n\n    tileAnimY(offset: number, count: number) {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - 4] = offset;\n        pb[pb.length - 1] = count;\n    }\n\n    renderCanvas(renderer: any) {\n        let plugin = renderer.plugins.tilemap;\n        if (!plugin.dontUseTransform) {\n            let wt = this.worldTransform;\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n        this.renderCanvasCore(renderer);\n    }\n\n    renderCanvasCore(renderer: any) {\n        if (this.textures.length === 0) return;\n        let points = this.pointsBuf;\n        const tileAnim = this.tileAnim || renderer.plugins.tilemap.tileAnim;\n        renderer.context.fillStyle = '#000000';\n        for (let i = 0, n = points.length; i < n; i += POINT_STRUCT_SIZE) {\n            let x1 = points[i], y1 = points[i + 1];\n            let x2 = points[i + 2], y2 = points[i + 3];\n            let w = points[i + 4];\n            let h = points[i + 5];\n            var rotate = points[i + 6];\n            x1 += points[i + 7] * tileAnim[0];\n            y1 += points[i + 8] * tileAnim[1];\n            let textureIndex = points[i + 9];\n            // canvas does not work with rotate yet\n            if (textureIndex >= 0) {\n                renderer.context.drawImage((this.textures[textureIndex].baseTexture as any).getDrawableSource(), x1, y1, w, h, x2, y2, w, h);\n            } else {\n                renderer.context.globalAlpha = 0.5;\n                renderer.context.fillRect(x2, y2, w, h);\n                renderer.context.globalAlpha = 1;\n            }\n        }\n    }\n\n    vbId = 0;\n    vb: RectTileGeom = null;\n    vbBuffer: ArrayBuffer = null;\n    vbArray: Float32Array = null;\n    vbInts: Uint32Array = null;\n\n    destroyVb() {\n        if (this.vb) {\n            this.vb.destroy();\n            this.vb = null;\n        }\n    }\n\n    render(renderer: Renderer) {\n        let plugin = (renderer.plugins as any)['tilemap'];\n        let shader = plugin.getShader();\n        renderer.batch.setObjectRenderer(plugin);\n        this._globalMat = shader.uniforms.projTransMatrix;\n        renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\n        shader.uniforms.shadowColor = this.shadowColor;\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\n        this.renderWebGLCore(renderer, plugin);\n    }\n\n    renderWebGLCore(renderer: Renderer, plugin: TileRenderer) {\n        let points = this.pointsBuf;\n        if (points.length === 0) return;\n        let rectsCount = points.length / POINT_STRUCT_SIZE;\n\n        let shader = plugin.getShader();\n        let textures = this.textures;\n        if (textures.length === 0) return;\n\n        plugin.bindTextures(renderer, shader, textures);\n        renderer.shader.bind(shader, false);\n\n        //lost context! recover!\n        let vb = this.vb;\n        if (!vb) {\n            vb = plugin.createVb();\n            this.vb = vb;\n            this.vbId = (vb as any).id;\n            this.vbBuffer = null;\n            this.modificationMarker = 0;\n        }\n\n        plugin.checkIndexBuffer(rectsCount, vb);\n        const boundCountPerBuffer = Constant.boundCountPerBuffer;\n\n        let vertexBuf = vb.getBuffer('aVertexPosition');\n        //if layer was changed, re-upload vertices\n        let vertices = rectsCount * vb.vertPerQuad;\n        if (vertices === 0) return;\n        if (this.modificationMarker !== vertices) {\n            this.modificationMarker = vertices;\n            let vs = vb.stride * vertices;\n            if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\n                //!@#$ happens, need resize\n                let bk = vb.stride;\n                while (bk < vs) {\n                    bk *= 2;\n                }\n                this.vbBuffer = new ArrayBuffer(bk);\n                this.vbArray = new Float32Array(this.vbBuffer);\n                this.vbInts = new Uint32Array(this.vbBuffer);\n                vertexBuf.update(this.vbBuffer);\n            }\n\n            let arr = this.vbArray, ints = this.vbInts;\n            //upload vertices!\n            let sz = 0;\n            //let tint = 0xffffffff;\n            let textureId: number = 0;\n            let shiftU: number = this.offsetX;\n            let shiftV: number = this.offsetY;\n\n            //let tint = 0xffffffff;\n            let tint = -1;\n            for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE) {\n                let eps = 0.5;\n                if (this.compositeParent) {\n                    if (boundCountPerBuffer > 1) {\n                        //TODO: what if its more than 4?\n                        textureId = (points[i + 9] >> 2);\n                        shiftU = this.offsetX * (points[i + 9] & 1);\n                        shiftV = this.offsetY * ((points[i + 9] >> 1) & 1);\n                    } else {\n                        textureId = points[i + 9];\n                        shiftU = 0;\n                        shiftV = 0;\n                    }\n                }\n                let x = points[i + 2], y = points[i + 3];\n                let w = points[i + 4], h = points[i + 5];\n                let u = points[i] + shiftU, v = points[i + 1] + shiftV;\n                let rotate = points[i + 6];\n\n                const animX = points[i + 7], animY = points[i + 8];\n                const animWidth = points[i + 10] || 1024, animHeight = points[i + 11] || 1024;\n                const animXEncoded = animX + (animWidth * 2048);\n                const animYEncoded = animY + (animHeight * 2048);\n\n                let u0: number, v0: number, u1: number, v1: number, u2: number, v2: number, u3: number, v3: number;\n                if (rotate === 0) {\n                    u0 = u;\n                    v0 = v;\n                    u1 = u + w;\n                    v1 = v;\n                    u2 = u + w;\n                    v2 = v + h;\n                    u3 = u;\n                    v3 = v + h;\n                } else {\n                    let w2 = w / 2;\n                    let h2 = h / 2;\n                    if (rotate % 4 !== 0) {\n                        w2 = h / 2;\n                        h2 = w / 2;\n                    }\n                    const cX = u + w2;\n                    const cY = v + h2;\n\n                    rotate = groupD8.add(rotate, groupD8.NW);\n                    u0 = cX + (w2 * groupD8.uX(rotate));\n                    v0 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n                    u1 = cX + (w2 * groupD8.uX(rotate));\n                    v1 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2);\n                    u2 = cX + (w2 * groupD8.uX(rotate));\n                    v2 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2);\n                    u3 = cX + (w2 * groupD8.uX(rotate));\n                    v3 = cY + (h2 * groupD8.uY(rotate));\n                }\n\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u0;\n                arr[sz++] = v0;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y;\n                arr[sz++] = u1;\n                arr[sz++] = v1;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u2;\n                arr[sz++] = v2;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x;\n                arr[sz++] = y + h;\n                arr[sz++] = u3;\n                arr[sz++] = v3;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n            }\n\n            vertexBuf.update(arr);\n        }\n\n        (renderer.geometry as any).bind(vb, shader);\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, rectsCount * 6, 0);\n    }\n\n    isModified(anim: boolean) {\n        if (this.modificationMarker !== this.pointsBuf.length ||\n            anim && this.hasAnim) {\n            return true;\n        }\n        return false;\n    }\n\n    clearModify() {\n        this.modificationMarker = this.pointsBuf.length;\n    }\n\n    protected _calculateBounds(): void\n    {\n        const { minX, minY, maxX, maxY } = this._$_localBounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            return this._$_localBounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    destroy(options?: any) {\n        super.destroy(options);\n        this.destroyVb();\n    }\n}\n","// @ts-nocheck\n/// <reference path=\"types.d.ts\" />\n\nimport { Container } from '@pixi/display';\nimport { Texture, Renderer } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\nimport { Constant } from './Constant';\nimport { RectTileLayer } from './RectTileLayer';\n\nexport class CompositeRectTileLayer extends Container {\n    constructor(zIndex?: number, bitmaps?: Array<Texture>, texPerChild?: number) {\n        super();\n        this.initialize.apply(this, arguments);\n    }\n\n    z: number;\n    zIndex: number;\n    modificationMarker = 0;\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    _globalMat: Matrix = null;\n    _lastLayer: RectTileLayer = null;\n\n    texPerChild: number;\n    tileAnim: Array<number> = null;\n\n    initialize(zIndex?: number, bitmaps?: Array<Texture>, texPerChild?: number) {\n        if (texPerChild as any === true) {\n            //old format, ignore it!\n            texPerChild = 0;\n        }\n        this.z = this.zIndex = zIndex;\n        this.texPerChild = texPerChild || Constant.boundCountPerBuffer * Constant.maxTextures;\n        if (bitmaps) {\n            this.setBitmaps(bitmaps);\n        }\n    }\n\n    setBitmaps(bitmaps: Array<Texture>) {\n        for (let i=0;i<bitmaps.length;i++) {\n            if (bitmaps[i] && !bitmaps[i].baseTexture) {\n                throw new Error(`pixi-tilemap cannot use destroyed textures. `+\n                    `Probably, you passed resources['myAtlas'].texture in pixi > 5.2.1, it does not exist there.`);\n            }\n        }\n        let texPerChild = this.texPerChild;\n        let len1 = this.children.length;\n        let len2 = Math.ceil(bitmaps.length / texPerChild);\n        let i: number;\n        for (i = 0; i < len1; i++) {\n            (this.children[i] as RectTileLayer).textures = bitmaps.slice(i * texPerChild, (i + 1) * texPerChild);\n        }\n        for (i = len1; i < len2; i++) {\n            let layer = new RectTileLayer(this.zIndex, bitmaps.slice(i * texPerChild, (i + 1) * texPerChild));\n            layer.compositeParent = true;\n            layer.offsetX = Constant.boundSize;\n            layer.offsetY = Constant.boundSize;\n            this.addChild(layer);\n        }\n    }\n\n    clear() {\n        for (let i = 0; i < this.children.length; i++) {\n            (this.children[i] as RectTileLayer).clear();\n        }\n        this.modificationMarker = 0;\n    }\n\n    addRect(textureIndex: number, u: number, v: number, x: number, y: number, tileWidth: number, tileHeight: number, animX?: number, animY?: number, rotate?: number, animWidth?: number, animHeight?: number): this {\n        const childIndex: number = textureIndex / this.texPerChild >> 0;\n        const textureId: number = textureIndex % this.texPerChild;\n\n        if (this.children[childIndex] && (this.children[childIndex] as RectTileLayer).textures) {\n            this._lastLayer = (this.children[childIndex] as RectTileLayer);\n            this._lastLayer.addRect(textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight);\n        } else {\n            this._lastLayer = null;\n        }\n\n        return this;\n    }\n\n    tileRotate(rotate: number): this {\n        if (this._lastLayer)\n        {\n            this._lastLayer.tileRotate(rotate);\n        }\n        return this;\n    }\n\n    tileAnimX(offset: number, count: number): this {\n        if (this._lastLayer)\n        {\n            this._lastLayer.tileAnimX(offset, count);\n        }\n        return this;\n    }\n\n    tileAnimY(offset: number, count: number): this {\n        if (this._lastLayer)\n        {\n            this._lastLayer.tileAnimY(offset, count);\n        }\n        return this;\n    }\n\n    addFrame(texture_: Texture | String | number, x: number, y: number, animX?: number, animY?: number, animWidth?: number, animHeight?: number): this {\n        let texture: Texture;\n        let layer: RectTileLayer = null;\n        let ind: number = 0;\n        let children = this.children;\n\n        this._lastLayer = null;\n        if (typeof texture_ === \"number\") {\n            let childIndex = texture_ / this.texPerChild >> 0;\n            layer = children[childIndex] as RectTileLayer;\n\n            if (!layer) {\n                layer = children[0] as RectTileLayer;\n                if (!layer) {\n                    return this;\n                }\n                ind = 0;\n            } else {\n                ind = texture_ % this.texPerChild;\n            }\n\n            texture = layer.textures[ind];\n        } else {\n            if (typeof texture_ === \"string\") {\n                texture = Texture.from(texture_);\n            } else {\n                texture = texture_ as Texture;\n            }\n\n            for (let i = 0; i < children.length; i++) {\n                let child = children[i] as RectTileLayer;\n                let tex = child.textures;\n                for (let j = 0; j < tex.length; j++) {\n                    if (tex[j].baseTexture === texture.baseTexture) {\n                        layer = child;\n                        ind = j;\n                        break;\n                    }\n                }\n                if (layer) {\n                    break;\n                }\n            }\n\n            if (!layer) {\n                for (let i = 0; i < children.length; i++) {\n                    let child = children[i] as RectTileLayer;\n                    if (child.textures.length < this.texPerChild) {\n                        layer = child;\n                        ind = child.textures.length;\n                        child.textures.push(texture);\n                        break;\n                    }\n                }\n                if (!layer) {\n                    layer = new RectTileLayer(this.zIndex, texture);\n                    layer.compositeParent = true;\n                    layer.offsetX = Constant.boundSize;\n                    layer.offsetY = Constant.boundSize;\n                    this.addChild(layer);\n                    ind = 0;\n                }\n            }\n        }\n\n        this._lastLayer = layer;\n        layer.addRect(ind, texture.frame.x, texture.frame.y, x, y, texture.orig.width, texture.orig.height, animX, animY, texture.rotate, animWidth, animHeight);\n        return this;\n    }\n\n    renderCanvas(renderer: any) {\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n            return;\n        }\n        let plugin = renderer.plugins.tilemap;\n        if (!plugin.dontUseTransform) {\n            let wt = this.worldTransform;\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n        let layers = this.children;\n        for (let i = 0; i < layers.length; i++) {\n            const layer = (layers[i] as RectTileLayer);\n            layer.tileAnim = this.tileAnim;\n            layer.renderCanvasCore(renderer);\n        }\n    }\n\n    render(renderer: Renderer) {\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n            return;\n        }\n        let plugin = (renderer.plugins as any)['tilemap'];\n        let shader = plugin.getShader();\n        renderer.batch.setObjectRenderer(plugin);\n        //TODO: dont create new array, please\n        this._globalMat = shader.uniforms.projTransMatrix;\n        renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\n        shader.uniforms.shadowColor = this.shadowColor;\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\n        renderer.shader.bind(shader, false);\n        let layers = this.children;\n        for (let i = 0; i < layers.length; i++) {\n            const layer = (layers[i] as RectTileLayer);\n            layer.renderWebGLCore(renderer, plugin);\n        }\n    }\n\n    isModified(anim: boolean) {\n        let layers = this.children;\n        if (this.modificationMarker !== layers.length) {\n            return true;\n        }\n        for (let i = 0; i < layers.length; i++) {\n            if ((layers[i] as RectTileLayer).isModified(anim)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    clearModify() {\n        let layers = this.children;\n        this.modificationMarker = layers.length;\n        for (let i = 0; i < layers.length; i++) {\n            (layers[i] as RectTileLayer).clearModify();\n        }\n    }\n}\n","// @ts-nocheck\n/// <reference path=\"types.d.ts\" />\n\nimport { Matrix } from '@pixi/math';\nimport { Graphics } from '@pixi/graphics';\n\nexport class GraphicsLayer extends Graphics {\n    constructor(zIndex: number) {\n        super();\n        this.zIndex = zIndex;\n    }\n\n    renderCanvas(renderer: any) {\n        let wt: Matrix = null;\n        if (renderer.plugins.tilemap.dontUseTransform) {\n            wt = this.transform.worldTransform;\n            this.transform.worldTransform = Matrix.IDENTITY;\n        }\n        renderer.plugins.graphics.render(this);\n        if (renderer.plugins.tilemap.dontUseTransform) {\n            this.transform.worldTransform = wt;\n        }\n        renderer.context.globalAlpha = 1.0;\n    }\n\n    // renderWebGL(renderer: PIXI.Renderer) {\n    //     if (!this._webGL[renderer.CONTEXT_UID])\n    //         this.dirty++;\n    //     super.renderWebGL(renderer)\n    // }\n\n    isModified(anim: boolean): boolean {\n        return false;\n    }\n\n    clearModify() {\n    }\n}\n","// @ts-nocheck\n/// <reference path=\"types.d.ts\" />\n\nimport { ALPHA_MODES } from '@pixi/constants';\nimport { BaseTexture, Renderer, Texture, GLTexture, resources } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { Constant } from './Constant';\n\nexport interface IMultiTextureOptions {\n\tboundCountPerBuffer: number;\n\tboundSize: number;\n\tbufferSize: number;\n\tDO_CLEAR?: boolean;\n}\n\nexport class MultiTextureResource extends resources.Resource {\n\tconstructor(options: IMultiTextureOptions) {\n\t\tsuper(options.bufferSize, options.bufferSize);\n\n\t\tconst bounds = this.boundSprites;\n\t\tconst dirties = this.dirties;\n\t\tthis.boundSize = options.boundSize;\n\t\tfor (let j = 0; j < options.boundCountPerBuffer; j++) {\n\t\t\tconst spr = new Sprite();\n\t\t\tspr.position.x = options.boundSize * (j & 1);\n\t\t\tspr.position.y = options.boundSize * (j >> 1);\n\t\t\tbounds.push(spr);\n\t\t\tdirties.push(0);\n\t\t}\n\t\tthis.DO_CLEAR = !!options.DO_CLEAR;\n\t}\n\n\tDO_CLEAR = false;\n\tboundSize: number = 0;\n\t_clearBuffer: Uint8Array = null;\n\n\tbind(baseTexture: BaseTexture) {\n\t\tif (this.baseTex) {\n\t\t\tthrow new Error('Only one baseTexture is allowed for this resource!')\n\t\t}\n\t\tthis.baseTex = baseTexture;\n\t\tsuper.bind(baseTexture);\n\t}\n\n\tbaseTex: BaseTexture = null;\n\tboundSprites: Array<Sprite> = [];\n\tdirties: Array<number> = [];\n\n\tsetTexture(ind: number, texture: Texture) {\n\t\tconst spr = this.boundSprites[ind];\n\t\tif (spr.texture.baseTexture === texture.baseTexture) {\n\t\t\treturn;\n\t\t}\n\t\tspr.texture = texture;\n\t\tthis.baseTex.update();\n\t\tthis.dirties[ind] = (this.baseTex as any).dirtyId;\n\t}\n\n\tupload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture) {\n\t\tconst { gl } = renderer as any;\n\n\t\tconst {width, height} = this;\n\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.alphaMode === undefined ||\n\t\t\ttexture.alphaMode === ALPHA_MODES.UNPACK);\n\n\t\tif (glTexture.dirtyId < 0) {\n\t\t\t(glTexture as any).width = width;\n\t\t\t(glTexture as any).height = height;\n\n\t\t\tgl.texImage2D(texture.target, 0,\n\t\t\t\ttexture.format,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\t0,\n\t\t\t\ttexture.format,\n\t\t\t\ttexture.type,\n\t\t\t\tnull);\n\t\t}\n\n\t\tconst doClear = this.DO_CLEAR;\n\t\tif (doClear && !this._clearBuffer) {\n\t\t\tthis._clearBuffer = new Uint8Array(Constant.boundSize * Constant.boundSize * 4);\n\t\t}\n\n\t\tconst bounds = this.boundSprites;\n\t\tfor (let i = 0; i < bounds.length; i++) {\n\t\t\tconst spr = bounds[i];\n\t\t\tconst tex = spr.texture.baseTexture;\n\t\t\tif (glTexture.dirtyId >= this.dirties[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst res = tex.resource as any;\n\t\t\tif (!tex.valid || !res || !res.source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (doClear && (tex.width < this.boundSize || tex.height < this.boundSize))\n\t\t\t{\n\t\t\t\tgl.texSubImage2D(texture.target, 0,\n\t\t\t\t\tspr.position.x,\n\t\t\t\t\tspr.position.y,\n\t\t\t\t\tthis.boundSize,\n\t\t\t\t\tthis.boundSize,\n\t\t\t\t\ttexture.format,\n\t\t\t\t\ttexture.type,\n\t\t\t\t\tthis._clearBuffer);\n\t\t\t}\n\t\t\tgl.texSubImage2D(texture.target, 0,\n\t\t\t\tspr.position.x,\n\t\t\t\tspr.position.y,\n\t\t\t\ttexture.format,\n\t\t\t\ttexture.type,\n\t\t\t\tres.source);\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","import { Constant } from './Constant';\n\nimport type { TilemapShader } from './RectTileShader';\n\n\nexport function fillSamplers(shader: TilemapShader, maxTextures: number) {\n    let sampleValues: Array<number> = [];\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n    shader.uniforms.uSamplers = sampleValues;\n\n    let samplerSize: Array<number> = [];\n    for (let i = 0; i < maxTextures; i++) {\n        samplerSize.push(1.0 / Constant.bufferSize);\n        samplerSize.push(1.0 / Constant.bufferSize);\n    }\n    shader.uniforms.uSamplerSize = samplerSize;\n}\n\nexport function generateFragmentSrc(maxTextures: number, fragmentSrc: string) {\n    return fragmentSrc.replace(/%count%/gi, maxTextures + \"\")\n        .replace(/%forloop%/gi, generateSampleSrc(maxTextures));\n}\n\nexport function generateSampleSrc(maxTextures: number) {\n    let src = '';\n\n    src += '\\n';\n    src += '\\n';\n\n    src += 'if(vTextureId <= -1.0) {';\n    src += '\\n\\tcolor = shadowColor;';\n    src += '\\n}';\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        src += '\\nelse ';\n\n        if(i < maxTextures-1)\n        {\n            src += 'if(textureId == ' + i + '.0)';\n        }\n\n        src += '\\n{';\n        src += '\\n\\tcolor = texture2D(uSamplers['+i+'], textureCoord * uSamplerSize['+i+']);';\n        src += '\\n}';\n    }\n\n    src += '\\n';\n    src += '\\n';\n\n    return src;\n}\n","/// <reference path=\"types.d.ts\" />\n\nimport * as shaderGenerator from './shaderGenerator';\n\nimport { Buffer, Geometry, Shader, Program } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nlet rectShaderFrag = `\nvarying vec2 vTextureCoord;\nvarying vec4 vFrame;\nvarying float vTextureId;\nuniform vec4 shadowColor;\nuniform sampler2D uSamplers[%count%];\nuniform vec2 uSamplerSize[%count%];\n\nvoid main(void){\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n   float textureId = floor(vTextureId + 0.5);\n\n   vec4 color;\n   %forloop%\n   gl_FragColor = color;\n}\n`;\nlet rectShaderVert = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aFrame;\nattribute vec2 aAnim;\nattribute float aTextureId;\n\nuniform mat3 projTransMatrix;\nuniform vec2 animationFrame;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vFrame;\n\nvoid main(void){\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\n   vec2 animOffset = animFrameOffset * floor(mod(animationFrame + 0.5, animCount));\n\n   vTextureCoord = aTextureCoord + animOffset;\n   vFrame = aFrame + vec4(animOffset, animOffset);\n   vTextureId = aTextureId;\n}\n`;\n\nexport abstract class TilemapShader extends Shader {\n\tmaxTextures = 0;\n\n\tconstructor(maxTextures: number, shaderVert: string, shaderFrag: string) {\n\t\tsuper(\n\t\t\tnew Program(\n\t\t\t\tshaderVert,\n\t\t\t\tshaderFrag),\n\t\t\t{\n\t\t\t\tanimationFrame: new Float32Array(2),\n\t\t\t\tuSamplers: [],\n\t\t\t\tuSamplerSize: [],\n\t\t\t\tprojTransMatrix: new Matrix()\n\t\t\t}\n\t\t);\n\t\tthis.maxTextures = maxTextures;\n\t\tshaderGenerator.fillSamplers(this, this.maxTextures);\n\t}\n}\n\nexport class RectTileShader extends TilemapShader {\n\tconstructor(maxTextures: number) {\n\t\tsuper(\n\t\t\tmaxTextures,\n\t\t\trectShaderVert,\n\t\t\tshaderGenerator.generateFragmentSrc(maxTextures, rectShaderFrag)\n\t\t);\n\t\tshaderGenerator.fillSamplers(this, this.maxTextures);\n\t}\n}\n\nexport class RectTileGeom extends Geometry {\n\tvertSize = 11;\n\tvertPerQuad = 4;\n\tstride = this.vertSize * 4;\n\tlastTimeAccess = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tconst buf = this.buf = new Buffer(new Float32Array(2), true, false);\n\t\tthis.addAttribute('aVertexPosition', buf, 0, false, 0, this.stride, 0)\n\t\t\t.addAttribute('aTextureCoord', buf, 0, false, 0, this.stride, 2 * 4)\n\t\t\t.addAttribute('aFrame', buf, 0, false, 0, this.stride, 4 * 4)\n\t\t\t.addAttribute('aAnim', buf, 0, false, 0, this.stride, 8 * 4)\n\t\t\t.addAttribute('aTextureId', buf, 0, false, 0, this.stride, 10 * 4);\n\t}\n\n\tbuf: Buffer;\n}\n","// @ts-nocheck\nimport { WRAP_MODES } from '@pixi/constants';\nimport { BaseTexture, Buffer, resources, ObjectRenderer, Texture, Renderer } from '@pixi/core';\nimport { Constant } from './Constant';\nimport { RectTileGeom, RectTileShader } from './RectTileShader';\nimport { MultiTextureResource } from './MultiTextureResource';\nimport * as PIXI from \"pixi.js\"\n\nimport type { TilemapShader } from './RectTileShader';\n\n/**\n * Renderer for rectangle tiles.\n */\nexport class TileRenderer extends ObjectRenderer {\n\trenderer: Renderer;\n\tgl: WebGLRenderingContext;\n\tsn: number = -1;\n\tindexBuffer: Buffer = null;\n\tibLen: number = 0;\n\ttileAnim = [0, 0];\n\ttexLoc: Array<number> = [];\n\n\trectShader: RectTileShader;\n\ttexResources: Array<MultiTextureResource> = [];\n\n\tconstructor(renderer: Renderer) {\n\t\tsuper(renderer);\n\t\tthis.rectShader = new RectTileShader(Constant.maxTextures);\n\t\tthis.indexBuffer = new Buffer(undefined, true, true);\n\t\tthis.checkIndexBuffer(2000);\n\t\tthis.initBounds();\n\t}\n\n\tinitBounds() {\n\t\tif (Constant.boundCountPerBuffer <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst maxTextures = Constant.maxTextures;\n\t\tfor (let i = 0; i < maxTextures; i++) {\n\t\t\tconst resource = new MultiTextureResource(Constant);\n\t\t\tconst baseTex = new BaseTexture(resource);\n\t\t\tbaseTex.scaleMode = Constant.SCALE_MODE;\n\t\t\tbaseTex.wrapMode = WRAP_MODES.CLAMP;\n\t\t\tthis.texResources.push(resource);\n\t\t}\n\t}\n\n\tbindTexturesWithoutRT(renderer: Renderer, shader: TilemapShader, textures: Array<Texture>) {\n\t\tlet samplerSize: Array<number> = (shader as any).uniforms.uSamplerSize;\n\t\tthis.texLoc.length = 0;\n\t\tfor (let i = 0; i < textures.length; i++) {\n\t\t\tconst texture = textures[i];\n\t\t\tif (!texture || !texture.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trenderer.texture.bind(textures[i], i);\n\t\t\t//TODO: add resolution here\n\t\t\tsamplerSize[i * 2] = 1.0 / textures[i].baseTexture.width;\n\t\t\tsamplerSize[i * 2 + 1] = 1.0 / textures[i].baseTexture.height;\n\t\t}\n\t\t(shader as any).uniforms.uSamplerSize = samplerSize;\n\t}\n\n\tbindTextures(renderer: Renderer, shader: TilemapShader, textures: Array<Texture>) {\n\t\tconst len = textures.length;\n\t\tconst maxTextures = Constant.maxTextures;\n\t\tif (len > Constant.boundCountPerBuffer * maxTextures) {\n\t\t\treturn;\n\t\t}\n\t\tif (Constant.boundCountPerBuffer <= 1) {\n\t\t\tthis.bindTexturesWithoutRT(renderer, shader, textures);\n\t\t\treturn;\n\t\t}\n\n\t\tlet i = 0;\n\t\tfor (; i < len; i++) {\n\t\t\tconst texture = textures[i];\n\t\t\tif (!texture || !texture.valid) continue;\n\t\t\tconst multi = this.texResources[i >> 2];\n\t\t\tmulti.setTexture(i & 3, texture);\n\t\t}\n\n\t\tlet gltsUsed = (i + 3) >> 2;\n\t\tfor (i = 0; i < gltsUsed; i++) {\n\t\t\t//remove \"i, true\" after resolving a bug\n\t\t\trenderer.texture.bind(this.texResources[i].baseTex, i);\n\t\t}\n\t}\n\n\tstart() {\n\t\t//sorry, nothing\n\t}\n\n\tcreateVb() {\n\t\tconst geom = new RectTileGeom();\n\t\tgeom.addIndex(this.indexBuffer);\n\t\tgeom.lastTimeAccess = Date.now();\n\t\treturn geom;\n\t}\n\n\tcheckIndexBuffer(size: number, vb: RectTileGeom = null) {\n\t\tconst totalIndices = size * 6;\n\n\t\tif (totalIndices <= this.ibLen) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet len = totalIndices;\n\t\twhile (len < totalIndices) {\n\t\t\tlen <<= 1;\n\t\t}\n\n\t\tthis.ibLen = totalIndices;\n\t\tthis.indexBuffer.update((PIXI as any).utils.createIndicesForQuads(size,\n\t\t\tConstant.use32bitIndex ? new Uint32Array(size * 6) : undefined));\n\n\t\t// \tTODO: create new index buffer instead?\n\t\t// if (vb) {\n\t\t// \tconst curIndex = vb.getIndex();\n\t\t// \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\n\t\t// \t\tthis.swapIndex(vb, this.indexBuffer);\n\t\t// \t}\n\t\t// }\n\t}\n\n\t// swapIndex(geom: PIXI.Geometry, indexBuf: PIXI.Buffer) {\n\t\t// let buffers = (geom as any).buffers;\n\t\t// const oldIndex = geom.getIndex();\n\t\t// let ind = buffers.indexOf(oldIndex);\n\t\t// if (ind >= 0) {\n\t\t// \tbuffers.splice(ind, 1);\n\t\t// }\n\t\t// geom.addIndex(indexBuf);\n\t// }\n\n\tgetShader(): TilemapShader {\n\t\treturn this.rectShader;\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\t// this.rectShader.destroy();\n\t\tthis.rectShader = null;\n\t}\n}\n\nRenderer.registerPlugin('tilemap', TileRenderer as any);\n","// @ts-nocheck\n/// <reference path=\"types.d.ts\" />\n\nimport { Container } from '@pixi/display';\n\nimport type { CompositeRectTileLayer } from './CompositeRectTileLayer';\nimport type { Matrix } from '@pixi/math';\n\nexport class ZLayer extends Container {\n\n    constructor(tilemap: Container, zIndex: number) {\n        super();\n        this.tilemap = tilemap;\n        this.z = zIndex;\n    }\n\n    tilemap: any;\n    z: number;\n    zIndex: number;\n    _previousLayers: number;\n    canvasBuffer: HTMLCanvasElement;\n    _tempRender: any;\n    _lastAnimationFrame: number = -1;\n    layerTransform: Matrix;\n\n    clear() {\n        let layers = this.children as Array<CompositeRectTileLayer>;\n        for (let i = 0; i < layers.length; i++)\n            layers[i].clear();\n        this._previousLayers = 0;\n    }\n\n    cacheIfDirty() {\n        let tilemap: any = this.tilemap;\n        let layers = this.children as Array<CompositeRectTileLayer>;\n        let modified = this._previousLayers !== layers.length;\n        this._previousLayers = layers.length;\n        let buf = this.canvasBuffer;\n        let tempRender = this._tempRender;\n        if (!buf) {\n            buf = this.canvasBuffer = document.createElement('canvas');\n            tempRender = this._tempRender = new (PIXI as any).CanvasRenderer({width: 100, height: 100, view: buf});\n            tempRender.context = tempRender.rootContext;\n            tempRender.plugins.tilemap.dontUseTransform = true;\n        }\n        if (buf.width !== tilemap._layerWidth ||\n            buf.height !== tilemap._layerHeight) {\n            buf.width = tilemap._layerWidth;\n            buf.height = tilemap._layerHeight;\n            modified = true;\n        }\n        let i: number;\n        if (!modified) {\n            for (i = 0; i < layers.length; i++) {\n                if (layers[i].isModified(this._lastAnimationFrame !== tilemap.animationFrame)) {\n                    modified = true;\n                    break;\n                }\n            }\n        }\n        this._lastAnimationFrame = tilemap.animationFrame;\n        if (modified) {\n            if (tilemap._hackRenderer) {\n                tilemap._hackRenderer(tempRender);\n            }\n            tempRender.context.clearRect(0, 0, buf.width, buf.height);\n            for (i = 0; i < layers.length; i++) {\n                layers[i].clearModify();\n                layers[i].renderCanvas(tempRender);\n            }\n        }\n        this.layerTransform = this.worldTransform;\n        for (i = 0; i < layers.length; i++) {\n            this.layerTransform = layers[i].worldTransform;\n            break;\n        }\n    }\n\n    renderCanvas(renderer: any) {\n        this.cacheIfDirty();\n        let wt = this.layerTransform;\n        renderer.context.setTransform(\n            wt.a,\n            wt.b,\n            wt.c,\n            wt.d,\n            wt.tx * renderer.resolution,\n            wt.ty * renderer.resolution\n        );\n        let tilemap = this.tilemap;\n        renderer.context.drawImage(this.canvasBuffer, 0, 0);\n    }\n}\n","var $ = require('../internals/export');\n\n// `Date.now` method\n// https://tc39.es/ecma262/#sec-date.now\n$({ target: 'Date', stat: true }, {\n  now: function now() {\n    return new Date().getTime();\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar global = require('../internals/global');\nvar arrayBufferModule = require('../internals/array-buffer');\nvar setSpecies = require('../internals/set-species');\n\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];\nvar NativeArrayBuffer = global[ARRAY_BUFFER];\n\n// `ArrayBuffer` constructor\n// https://tc39.es/ecma262/#sec-arraybuffer-constructor\n$({ global: true, forced: NativeArrayBuffer !== ArrayBuffer }, {\n  ArrayBuffer: ArrayBuffer\n});\n\nsetSpecies(ARRAY_BUFFER);\n","var createTypedArrayConstructor = require('../internals/typed-array-constructor');\n\n// `Uint32Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint32', function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n"],"sourceRoot":""}